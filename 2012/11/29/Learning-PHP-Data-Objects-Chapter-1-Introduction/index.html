<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Learning PHP Data Objects Chapter 1 Introduction | Song</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍PHP数据对象是PHP5的轻量级的DBMS连接抽象库扩展，（也称数据访问抽象库）。PHP支持的大多数据库系统需要像PDO标准数据接口的工具。每一个数据库系统需要独立的扩展，它定义执行相同任务的API，从建立连接到更高级的特性，如预处理语句、错误处理。 事实上这些接口没有被统一，使得基础数据转换倍加棘手，常常导致许多代码要重写，花销更多的时间去查找，调试，修改出现的错误。另一方面，缺少像java">
<meta name="keywords" content="PHP,PDO">
<meta property="og:type" content="article">
<meta property="og:title" content="Learning PHP Data Objects Chapter 1 Introduction">
<meta property="og:url" content="https://blog.sonjin.com/2012/11/29/Learning-PHP-Data-Objects-Chapter-1-Introduction/index.html">
<meta property="og:site_name" content="Song">
<meta property="og:description" content="介绍PHP数据对象是PHP5的轻量级的DBMS连接抽象库扩展，（也称数据访问抽象库）。PHP支持的大多数据库系统需要像PDO标准数据接口的工具。每一个数据库系统需要独立的扩展，它定义执行相同任务的API，从建立连接到更高级的特性，如预处理语句、错误处理。 事实上这些接口没有被统一，使得基础数据转换倍加棘手，常常导致许多代码要重写，花销更多的时间去查找，调试，修改出现的错误。另一方面，缺少像java">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-19T07:47:08.075Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning PHP Data Objects Chapter 1 Introduction">
<meta name="twitter:description" content="介绍PHP数据对象是PHP5的轻量级的DBMS连接抽象库扩展，（也称数据访问抽象库）。PHP支持的大多数据库系统需要像PDO标准数据接口的工具。每一个数据库系统需要独立的扩展，它定义执行相同任务的API，从建立连接到更高级的特性，如预处理语句、错误处理。 事实上这些接口没有被统一，使得基础数据转换倍加棘手，常常导致许多代码要重写，花销更多的时间去查找，调试，修改出现的错误。另一方面，缺少像java">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/scrollUp/image.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">Song</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">Song</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value class="search-form-submit">
        <input name="tn" type="hidden" value="bds">
        <input name="cl" type="hidden" value="3">
        <input name="ct" type="hidden" value="2097152">
        <input type="hidden" name="si" value="blog.sonjin.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Learning-PHP-Data-Objects-Chapter-1-Introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/11/29/Learning-PHP-Data-Objects-Chapter-1-Introduction/" class="article-date">
  <time datetime="2012-11-29T07:54:10.000Z" itemprop="datePublished">2012-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Learning PHP Data Objects Chapter 1 Introduction
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PHP数据对象是PHP5的轻量级的DBMS连接抽象库扩展，（也称数据访问抽象库）。PHP支持的大多数据库系统需要像PDO标准数据接口的工具。每一个数据库系统需要独立的扩展，它定义执行相同任务的API，从建立连接到更高级的特性，如预处理语句、错误处理。</p>
<p>事实上这些接口没有被统一，使得基础数据转换倍加棘手，常常导致许多代码要重写，花销更多的时间去查找，调试，修改出现的错误。另一方面，缺少像java的JDBC一样的统一库，PHP落后于编程世界最大者。现在类似的库出现，PHP重获它的地位，成为千万编程者的平台。</p>
<p>说明一下，已经存在与PDO功用一样的 PHP库，最流行的是ADOdb库和PEAR DB.它们最主要的区别是速度.PDO是编译语言写的PHP扩展,而PHP库是解释语言写出的.PDO一旦被激活,不需要把它引用到你的脚本中,也不用在你的应用程序里从新配置它,因为终端用户不关心其它软件,这使得安装应用很方便.</p>
<p>提示:在这里我们不比较PHP库和PDO或推荐PDO代替这些PHP库,我们只是展示一下这个扩散的优点和缺点.比如说,PEAR包,MDB2,有更多功能的高级数据抽像库,这些PDO没有.</p>
<p>PDO 是PECL的一个扩展,它依赖于数据库特性驱动程序和其它PECL扩展.为了使用PDO这些驱动程序必须安装(你只需在使用的数据库的驱动程序).PDO 和数据库特性驱动程序的安装已经超出本书讨论的范围,你可到<a href="www.php.net/pdo">www.php.net/pdo</a> 的手册中查找安装和升级的信息.</p>
<h2 id="使用PDO"><a href="#使用PDO" class="headerlink" title="使用PDO"></a>使用PDO</h2><p>上一节我们解释了PDO是连接或数据访问抽像库.言之意PDO为创建和维护数据内容,执行查询,引用变量,遍历结果集,处理准备语句,错误处理,定义了统一的接口.<br>我们快速预览这些主题,在接下来的章节详细讨论.</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>先看一下经典的MYSQL连接方法:</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_connect($host,$user,$password)<span class="comment">;</span></span><br><span class="line">mysql_select_db($db)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们创建了一个连接并为这个连接选择了默认数据库(我们忽略了可能出现的错误问题).<br>在SQLite,我们将像下面的例句那样写:</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dbh = sqlite_open($db,<span class="number">0666</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里我也忽略了错误问题(我们以后在这方面介绍更多),为了完整,再让我们看看怎么去连接PostgreSQL:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_connect(<span class="string">"host=<span class="variable">$host</span> dbname=<span class="variable">$db</span> user=<span class="variable">$user</span> password=<span class="variable">$password</span>"</span>);</span><br></pre></td></tr></table></figure>
<p>正如你看到的, 三个数据库需要完全不同的方式建立连接.它现在不是一个问题,但如果你总使用同一个数据库管理系统,万一要改变,你将改写你的脚本.<br>现在让我们看看PDO必须提供什么.因为PDO是面向对象的,我们将使用连接对象并调用对象的各种方法来处理数据库的交互.上面的例子的含意:一些类似连接对象，需要调用mysql_connect or pg_connetc 并且返回链接标识和PHP特殊变量类型:资源.我们没有使用连接对象,因为我们在只使用一个连接的脚本中不要求我们直接使用两个数据库接口.但SQLite要有一个链接符.</p>
<p>关于 PDO,我们必须直接使用连接对象,因为没有别的途径引用它的方法.(不熟悉面向对象编程可查阅附录A)</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">For</span> MySQL:</span><br><span class="line"><span class="variable">$conn</span> = new PDO(<span class="string">"mysql:host=<span class="variable">$host</span>;dbname=<span class="variable">$db</span>"</span>, <span class="variable">$user</span>, <span class="variable">$pass</span>);</span><br><span class="line">// <span class="keyword">For</span> SQLite:</span><br><span class="line"><span class="variable">$conn</span> = new PDO(<span class="string">"sqlite:<span class="variable">$db</span>"</span>);</span><br><span class="line">// And <span class="keyword">for</span> PostgreSQL:</span><br><span class="line"><span class="variable">$conn</span> = new PDO(<span class="string">"pgsql:host=<span class="variable">$host</span> dbname=<span class="variable">$db</span>"</span>, <span class="variable">$user</span>, <span class="variable">$pass</span>);</span><br></pre></td></tr></table></figure>
<p>正如你看到的,唯一改动之处是第一个参数传递给PDO构造函数,至于SQLite,它不用设置密码和用户名,第二和第三参数可以省略.</p>
<p>提示:SQLite不是数据库服务器,但它是嵌入可以打开本地文件的SQL数据库仓库.更多关于SQLite的介绍和使用可以在 <a href="http://www.sqlite.org和www.php.net/sqlite/" target="_blank" rel="noopener">www.sqlite.org和www.php.net/sqlite/</a> 找到.更多通过PDO使用SQLite的信息在 <a href="http://www.php.net/manual/en/ref.pdo-sqlite.php" target="_blank" rel="noopener">www.php.net/manual/en/ref.pdo-sqlite.php</a></p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>从上一个例子中我们了解到,PDO使用所谓的连接字符串(或数据源名称,简称DSN),它允许PDO构造函数选择合适的驱动程序并通过随后的方法引用它.这些连接字符串或DSNs对不同数据库管理系统不同的,我们要做的去改变它.<br>如果你设计了一个大的应用程序,它可能在不同的数据库中可以使用,所以连接字符串(连同连接用户名和密码)可以定义在一个配置文件中,以下面的方式使用.(假设你的配置文件类似php.ini)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$config = parse_ini_file($pathToConfigFile);</span><br><span class="line">$conn = <span class="keyword">new</span> PDO($config[<span class="string">'db.conn'</span>], $config[<span class="string">'db.user'</span>],$config[<span class="string">'db.pass'</span>]);</span><br></pre></td></tr></table></figure>
<p>你的配置文件可能像这样</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="attribute">conn</span>=<span class="string">"mysql:host=localhost;dbname=test"</span></span><br><span class="line">db.<span class="attribute">user</span>=<span class="string">"johns"</span></span><br><span class="line">db.<span class="attribute">pass</span>=<span class="string">"mypassphrase"</span></span><br></pre></td></tr></table></figure>
<p>在第二章关于连接字符串有更多的说明,现在我们快速通过一个例子演示通过PDO连接不同的数据库是多么的简单.</p>
<p>执行查询，引用变量，处理结果集<br>如果PDO不超越单一接口去创建数据库连接，就不值用整本书来讲述。上例中介绍的PDO对象拥有需要统一执行查询的全部方法，不管所使用的数据库。让我们考虑一个简单的查询，它将从一个虚拟的二手车店数据库中选出所有属性为make的车，就像下面的查询语句：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> make <span class="keyword">FROM</span> cars <span class="keyword">ORDER</span> <span class="keyword">BY</span> make;</span><br></pre></td></tr></table></figure>
<p>之前，我们要根据不同的数据库调用不对的方法：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let's keep our SQL in a single variable</span></span><br><span class="line">$sql = <span class="string">'SELECT DISTINCT make FROM cars ORDER BY make'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, assuming MySQL:</span></span><br><span class="line">mysql_connect(<span class="string">'localhost'</span>, <span class="string">'boss'</span>, <span class="string">'password'</span>);</span><br><span class="line">mysql_select_db(<span class="string">'cars'</span>);</span><br><span class="line">$q = mysql_query($sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For SQLite we would do:</span></span><br><span class="line">$dbh = sqlite_open(<span class="string">'/path/to/cars.ldb'</span>, <span class="number">0666</span>);</span><br><span class="line">$q = sqlite_query($sql, $dbh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// And for PostgreSQL:</span></span><br><span class="line">pg_connect(<span class="string">"host=localhost dbname=cars user=boss</span></span><br><span class="line"><span class="string">password=password"</span>);</span><br><span class="line">$q = pg_query($sql);</span><br></pre></td></tr></table></figure>
<p>现在看下使用PDO，我们可以像下面那样做：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume the $connStr variable holds a valid connection string</span></span><br><span class="line"><span class="comment">// as discussed in previous point</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">'SELECT DISTINCT make FROM cars ORDER BY make'</span>;</span><br><span class="line">$conn = <span class="keyword">new</span> PDO($connStr, <span class="string">'boss'</span>, <span class="string">'password'</span>);</span><br><span class="line">$q = $conn-&gt;query($sql);</span><br></pre></td></tr></table></figure>
<p>正如你看到的，执行假设查询，PDO与传统方式很大的不同。此外，这里应该强调一下，通过调用 $conn-&gt;query()，返回PDOStatement类的另外一个对象，不像去调用mysql_query(), sqlite_query(), and pg_query(),返回是PHP变量：资源。现在使简单查询复杂一点，从虚构的汽车店选出所有在销售的福特汽车，查询语句就会像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(price) <span class="keyword">FROM</span> cars <span class="keyword">WHERE</span> make=<span class="string">'Ford'</span></span><br></pre></td></tr></table></figure>
<p>为了使例子更有趣，在查询之前,我们声明$make为停产的汽车的名字并引用它。<br>普通查询方式是这样的</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$make</span> = <span class="string">'Ford'</span>;</span><br><span class="line">/<span class="regexp">/ MySQL:</span></span><br><span class="line"><span class="regexp">$m = mysql_real_escape_string($make);</span></span><br><span class="line"><span class="regexp">$q = mysql_query("SELECT sum(price) FROM cars WHERE make='$m'");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ SQLite:</span></span><br><span class="line"><span class="regexp">$m = sqlite_escape_string($make);</span></span><br><span class="line"><span class="regexp">$q = sqlite_query("SELECT sum(price) FROM cars WHERE make='$m'",$dbh);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ and PostgreSQL:</span></span><br><span class="line"><span class="regexp">$m = pg_escape_string($make);</span></span><br><span class="line"><span class="regexp">$q = pg_query("SELECT sum(price) FROM cars WHERE make='$m'");</span></span><br></pre></td></tr></table></figure>
<p>PDO类定义了一个专门引用字符串的方法，它可使查询更安全。在第三章我们将讨论潜在的安全问题，如SQL注入。这个方法起到一个修正的作用，如果有可能它会自动在值的旁边加上引号。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$m</span> = <span class="variable">$conn</span>-&gt;<span class="keyword">quote</span>(<span class="variable">$make</span>);</span><br><span class="line"><span class="variable">$q</span> = <span class="variable">$conn</span>-&gt;query(<span class="string">"SELECT sum(price) FROM cars WHERE make=$m"</span>);</span><br></pre></td></tr></table></figure>
<p>你看到PDO充许使用和你以前使用的相同模式，但方法的名字是统一的。</p>
<p>现在，我们已经搞定查询语句，我们也将看到查询结果。在最后的例子中，我们不仅想得到一行结果，而且想要更多行，所以，这三个数据需要在mysql_query(), sqlite_query(),pg_query()中引用不同的方法，得到返回的变量$q;所以我们得到所有汽车的代码将和下面的相似：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume the query is in the $sql variable</span></span><br><span class="line">$sql = <span class="string">"SELECT DISTINCT make FROM cars ORDER BY make"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For MySQL:</span></span><br><span class="line">$q = mysql_query($sql);</span><br><span class="line"><span class="keyword">while</span>($r = mysql_fetch_assoc($q))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $r[<span class="string">'make'</span>], <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For SQLite:</span></span><br><span class="line">$q = sqlite_query($dbh, $sql);</span><br><span class="line"><span class="keyword">while</span>($r = sqlite_fetch_array($q, SQLITE_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $r[<span class="string">'make'</span>], <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and, finally, PostgreSQL:</span></span><br><span class="line">$q = pg_query($sql);</span><br><span class="line"><span class="keyword">while</span>($r = pg_fetch_assoc($q))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $r[<span class="string">'make'</span>], <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你看到的，方法的意思是一样的，但必须调用不同名字的方法。注意到如果我们想得到MYSQL和PostgreSQL一样的行，SQLite需要加一个参数。（当然，它也可以省略，但返回的行会包括列名为主健和数字为主键的元素）<br>你可能已经想过，通过使用PDO，事情会变的直接明了：我们并没有在意数据库，取得行的方法适用所有数据库。可以下面的方式重新上面的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$q = $conn-&gt;query(<span class="string">"SELECT DISTINCT make FROM cars ORDER BY make"</span>);</span><br><span class="line"><span class="keyword">while</span>($r = $q-&gt;fetch(PDO::FETCH_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $r[<span class="string">'make'</span>], <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所发生的与之前没有什么不同。一点要注意到，我们在这里明确地指定了获取方式 PDO::FETCH_ASSOC，因为PDO的默认行为是取得一个列名和数据为索引的数组。（与没有第二个参数的 mysql_fetch_array(),sqlite_fetch_array() 相似，还有pg_fetch_array()）我们将在第二章节讨论PDO提供的获取方式。</p>
<blockquote>
<p>提示： 最后的例子中，我们没有使用 html缩进是因为我们使用了新行字符来分隔输出的行，在实际的网页中，你可把 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$r</span>[<span class="string">'make'</span>], <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>
<p>改写为 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$r</span>[<span class="string">'make'</span>], <span class="string">"&lt;br&gt;\n"</span></span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>上面的例子没有验证错误，所以称不上真正实用的程序.<br>当处理与数据库有关的工作，我们必须在连接一个数据库和选择数据库和执行查询时，验证错误是否发生，大部分网络程序在出现问题时仅显示一个错误信息，（可能会有敏感信息,所以不需要显示所有错误细节）,但检测一个错误时,你(作为开发者)可能需要尽可能多的错误详细信息,这样你可以在最少的时间内修正这个错误.<br>有关数据库的脚本显示错误,最简单的方案可以像这样:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// For SQLite:</span><br><span class="line">$dbh = sqlite_open(<span class="string">'/path/to/cars.ldb'</span>, <span class="number">0666</span>) <span class="keyword">or</span> <span class="keyword">die</span></span><br><span class="line">(<span class="string">'Error opening SQLite database: '</span> .</span><br><span class="line">sqlite_error_string(sqlite_last_error($dbh)));</span><br><span class="line">$q = sqlite_query(<span class="string">"SELECT DISTINCT make FROM cars ORDER BY make"</span>,</span><br><span class="line">$dbh) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Could not execute query because: '</span> .</span><br><span class="line">sqlite_error_string(sqlite_last_error($dbh)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">and</span>, finally, <span class="keyword">for</span> PostgreSQL:</span><br><span class="line">pg_connect(<span class="string">"host=localhost dbname=cars user=boss</span></span><br><span class="line"><span class="string">password=password"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Could not connect to</span></span><br><span class="line"><span class="string">PostgreSQL: . pg_last_error());</span></span><br><span class="line"><span class="string">$q = pg_query("SELECT DISTINCT make FROM cars ORDER BY make")</span></span><br><span class="line"><span class="string">or die('</span>Could <span class="keyword">not</span> execute query because: <span class="string">' . pg_last_error());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如你看到的,SQLite与Mysql和PostgreSQL处理错误有些不同.(注意引用 sqlite_error_string(sqlite_last_error($dbh)).)</span></span><br></pre></td></tr></table></figure>
<p>在我们了解如何使用PDO实现同样的错误处理方式之前,要注意到它将是唯一一个PDO三个假设的处理错误方式.在本书的以后章节中详细说明.接下来我们将使用这个最简方案:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PDO error handling</span></span><br><span class="line"><span class="comment">// Assume the connection string is one of the following:</span></span><br><span class="line"><span class="comment">// $connStr = 'mysql:host=localhost;dbname=cars'</span></span><br><span class="line"><span class="comment">// $connStr = 'sqlite:/path/to/cars.ldb';</span></span><br><span class="line"><span class="comment">// $connStr = 'pgsql:host=localhost dbname=cars';</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO($connStr, <span class="string">'boss'</span>, <span class="string">'password'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $pe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Could not connect to the database because: '</span> .</span><br><span class="line">    $pe-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">$q = $conn-&gt;query(<span class="string">"SELECT DISTINCT make FROM cars ORDER BY make"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!$q)</span><br><span class="line">&#123;</span><br><span class="line">    $ei = $conn-&gt;errorInfo();</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Could not execute query because: '</span> . $ei[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示PDO强制我们使用一个轻量级的与传统不同的方法。<br>在try …catch块中我们调用PDO的构造函数(对PHP的面向对象感到陌生，可到P附录A中查询)这是因为PDO可以被调用就没有异常，（事实上，PDO的默认行为不去处理异常）但是在这里不可避免有异常情形。如果调用构造函数失败，异常将被执行。</p>
<p>捕捉异常是一个很好的主意，因为PHP中止脚本运行 ，并显示像这样的错误信息：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Uncaught exception <span class="string">'PDOException'</span> <span class="keyword">with</span> <span class="keyword">message</span> <span class="string">'SQLSTATE[28000] [1045] Access denied for user '</span>bosss<span class="string">'@'</span>localhost<span class="string">' (using password: YES)'</span> <span class="keyword">in</span> /<span class="keyword">var</span>/www/html/pdo.php5:<span class="number">3</span> Stack trace: <span class="string">#0</span> c:\www\hosts\localhost\pdo.php5(<span class="number">3</span>): PDO-&gt;__construct(<span class="string">'mysql:host=loca...'</span>, <span class="string">'bosss'</span>, <span class="string">'password'</span>, <span class="keyword">Array</span>) <span class="string">#1</span> <span class="comment">&#123;main&#125;</span> thrown <span class="keyword">in</span> /<span class="keyword">var</span>/www/html/pdo.php5 <span class="keyword">on</span> line <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在引用 PDO的构造函数时，我们让异常情形提供错误的名字，bosss。因为你看到输出的内容，它包括一些不想让别人看到的细节，所有像文件名，脚本路径，使用数据库的类形，用户名和密码,更多重要的信息。假设我们使用正确的用户名和别的一些让数据库服务器出错信息，屏幕将会显示真实的用户名和密码。<br>如果我们适当捕捉到异常，输出的错误将是这样：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLSTATE[<span class="number">28000</span>] [<span class="number">1045</span>] Access denied <span class="keyword">for</span> user <span class="string">'bosss'</span>@<span class="string">'localhost'</span> (<span class="keyword">using</span> password: <span class="keyword">YES</span>)</span><br></pre></td></tr></table></figure>
<p>这个错误信息包括很少的敏感信息，（事实上，这个输出很像我们一个没有使用PDO例子发出的输出）还是要再一次的提醒你，最好的方法是只显示自然的错误信息，比如：“对不起，服务器暂时不能被连接，请稍后重试”。当然你也可以记录所有的错误，这样当一些错误出现后，你就能找到它们。</p>
<p>###处理语句</p>
<p>这是一个相当高深的话题，但一会你就会熟悉它。如果你在使用PHP和Mysql或SQLite,可能还没有听说过预处理语句，因为它的扩展没有这样的特性。PostgreSQL用户可能已经一并使用过使用过pg_prepare和 pg_execute();MySQLi(优化过的mysql扩展)也提供预处理语句功能的扩展，但不是一个很好的方法。<br>如果对预处理语句不太熟悉，为你准备了一个小例子。</p>
<p>当开发数据库驱动，动态交互程序，你将或早或晚要从用户那里取得输入数据（它可能来自一个表单），并把它传递给数据库查询语句。例如，对于我们的汽车数据库，你可能会设计一个能列出任意两个年份中间生产的汽车，如果你充许用户从表单里提交年份，代码就像这样：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Suppose the years come <span class="keyword">in</span> the startYear <span class="literal">and</span> endYear</span><br><span class="line">// request variables:</span><br><span class="line">$sy = (<span class="built_in">int</span>)$_REQUEST[<span class="string">'startYear'</span>]<span class="comment">;</span></span><br><span class="line">$ey = (<span class="built_in">int</span>)$_REQUEST[<span class="string">'endYear'</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($ey &lt; $sy)</span><br><span class="line">&#123;</span><br><span class="line">    // ensure $sy is less than $ey</span><br><span class="line">    $tmp = $ey<span class="comment">;</span></span><br><span class="line">    $ey = $sy<span class="comment">;</span></span><br><span class="line">    $sy = $tmp<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"SELECT * FROM cars WHERE year &gt;= $sy AND year &lt;= $ey"</span><span class="comment">;</span></span><br><span class="line">// <span class="built_in">send</span> the query <span class="keyword">in</span> $sql…</span><br></pre></td></tr></table></figure>
<p>例子中的查询依赖两个变量，也是构成SQL的一部分，在PDO与之对应的预处理语句将是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = '<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cars <span class="keyword">WHERE</span> <span class="keyword">year</span> &gt;= ? <span class="keyword">AND</span> <span class="keyword">year</span> &lt;= ?<span class="string">';</span></span><br></pre></td></tr></table></figure>
<p>如你所见，我们查询语句中使用占位符替代了变量$sy和$ey。现在我们可以利用查询创建一个预处理语句.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming we have already connected and prepared</span></span><br><span class="line"><span class="comment">// the $sy and $ey variables</span></span><br><span class="line">$sql = <span class="string">'SELECT * FROM cars WHERE year &gt;= ? AND year &lt;= ?'</span>;</span><br><span class="line">$stmt = $conn-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;execute(<span class="keyword">array</span>($sy, $ey));</span><br></pre></td></tr></table></figure>
<p>这三行代码告诉我们预处理语句是对象（基于PDOStatement）.它们被创后引用 PDO::prepare()。PDO::prepare()以一个有占位符的SQL语句作为它的参数。<br>预处理语句通过引用the PDOStatement::execute()方法取得查询结果。正如例子显示的，我们引用的方法的参数是一个数组，此数组的拥有替代占位符的值。那数组的值是怎么对应上查询语句上的占位符呢,很明显，数组中元素的位置必须与查询语句中占位符的位置要一致。</p>
<p>你可能注意到我们没有为结果以变量的形式保存，这是因为语句本身来保存查询结果，所以你可以把我们可以把例子以这样来完成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suppose the years come in the startYear and endYear</span></span><br><span class="line"><span class="comment">// request variables:</span></span><br><span class="line">$sy = (int)$_REQUEST[<span class="string">'startYear'</span>];</span><br><span class="line">$ey = (int)$_REQUEST[<span class="string">'endYear'</span>];</span><br><span class="line"><span class="keyword">if</span>($ey &lt; $sy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ensure $sy is less than $ey</span></span><br><span class="line">    $tmp = $ey;</span><br><span class="line">    $ey = $sy;</span><br><span class="line">    $sy = $tmp;</span><br><span class="line">&#125;</span><br><span class="line">$sql = <span class="string">'SELECT * FROM cars WHERE year &gt;= ? AND year &lt;= ?'</span>;</span><br><span class="line">$stmt = $conn-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;execute(<span class="keyword">array</span>($sy, $ey));</span><br><span class="line"></span><br><span class="line"><span class="comment">// now iterate over the result as if we obtained</span></span><br><span class="line"><span class="comment">// the $stmt in a call to PDO::query()</span></span><br><span class="line"><span class="keyword">while</span>($r = $stmt-&gt;fetch(PDO::FETCH_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$r[make] $r[model] $r[year]\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过完整的例子了解到，我们调用 PDOStatement::fetch()方法直到它返回值为假时，退出循环，就像前面例子中讨论遍历结果集。<br>当然替换问号占位符为真实值不是预处理语句唯一能做的事。它的强大之处是可被无限次的执行。就是说我们可以多次引用PDOStatement::execute()都可以，每次我们可以为占位符设置不同的值，就像这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">'SELECT * FROM cars WHERE year &gt;= ? AND year &lt;= ?'</span>;</span><br><span class="line">$stmt = $conn-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the 'new' cars:</span></span><br><span class="line">$stmt-&gt;execute(<span class="keyword">array</span>(<span class="number">2005</span>, <span class="number">2007</span>));</span><br><span class="line">$newCars = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now, 'older' cars:</span></span><br><span class="line">$stmt-&gt;execute(<span class="keyword">array</span>(<span class="number">2000</span>, <span class="number">2004</span>));</span><br><span class="line">$olderCars = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show them</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'We have '</span>, count($newCars), <span class="string">' cars dated 2005-2007'</span>;</span><br><span class="line">print_r($newCars);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'Also we have '</span>, count($olderCars), <span class="string">' cars dated 2000-2004'</span>;</span><br><span class="line">print_r($olderCars);</span><br></pre></td></tr></table></figure>
<p>预处理语句执行速度比引用PDO::query()快一些，因为在调用PDO::prepare时，数据库驱动只优化他们一次。另外使用预处理语句的好处是调用PDO::execute时不必引用传递过来的参数。<br>在例子里我们把请求的变量显示转换成整数，我们也可以按下面的做：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume we also want to filter by make</span></span><br><span class="line">$sql = <span class="string">'SELECT * FROM cars WHERE make=?'</span>;</span><br><span class="line">$stmt = $conn-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;execute(<span class="keyword">array</span>($_REQUEST[<span class="string">'make'</span>]));</span><br></pre></td></tr></table></figure>
<p>［这段文字翻译不准确］<br>要注意到预处理语句在执行查询所造成的引号,在这里要结束对预处理语句的介绍，最大特点是PDO为所支持的数据库仿效它们。它的意思是在任何数据库里可以使用预处理。甚至不知道它们是什么。</p>
<h3 id="正确理解PDO"><a href="#正确理解PDO" class="headerlink" title="正确理解PDO"></a>正确理解PDO</h3><p>我们的介绍可能是不全面的，PDO是数据库连接抽象库，所以不能确定你的代码可以在每个数据上被支持，唯一可行的就是你的SQL代码是可以移植的，比如，mysql扩展了插入的SQL语法：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mytable <span class="builtin-name">SET</span> <span class="attribute">x</span>=1, <span class="attribute">y</span>=<span class="string">'two'</span>;</span><br></pre></td></tr></table></figure>
<p>这种SQL代码是不能被移植的，别的数据库是不能理解这个种插入方法，为了保证你的代码在不同的数据库之前能会正常运行 ，你要以下面的代码替换它：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(x, y) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'two'</span>);</span><br></pre></td></tr></table></figure>
<p>例子中不兼容的情况可能在你使用PDO时就会出现，它只有能过保证数据库模式和SQL可移植，你的代码才能与别的数据库兼容。当然，确保这种可移植性超了出书写范围。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这章介绍了以PHP5用PDO开发动态的数据库驱动的应用的基础知识。我们也看到PDO是怎么有效去除不同传统数据库访问接口的差异和提供简洁、可移植的代码。<br>在下面章节里我们将详细了解到这章里讨论过的特性，充分利用PHP数据对象扩展。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://blog.sonjin.com/2012/11/29/Learning-PHP-Data-Objects-Chapter-1-Introduction/" data-id="cjsbmkyjn000538ccfnx6z848" class="article-share-link">分享到</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PDO/">PDO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/">PHP</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/02/15/DIY-Media-Server/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          DIY Media Server
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Song<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>



<script src="/js/jquery.scrollUp.min.js"></script>
<script src="/js/jquery.transform.js"></script>
<script src="/js/menu.js"></script>

<script src="/js/script.js"></script>
<script src="/js/scrollUp.js"></script>

  </div>
</body>
</html>